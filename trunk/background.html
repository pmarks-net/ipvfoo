<!--
Copyright (C) 2011  Paul Marks  http://www.pmarks.net/

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
<script type="text/javascript">

/*
Lifecycle documentation:

The purpose of requestMap is to copy tabInfo from wR.onBeforeRequest to
wR.onResponseStarted (where the IP address is available.)  A map entry
normally begins/ends with these two calls, but it could also be deleted
in wR.onCompleted or wR.onErrorOccurred if something bad happens.

An entry in tabMap tries to approximate one "page view".  It begins (or resets)
in wR.onBeforeRequest(main_frame), and goes away in tabs.onRemoved.

UI updates begin in wN.onCommitted, which (hopefully) comes after
wR.onResponseStarted(main_frame).  Updates continue as new requests are made,
and stop in wR.onBeforeRequest(main_frame), i.e. the next page load.
*/

// requestId -> {tabInfo}
requestMap = {};

// For the list of fields, see onBeforeRequest() below.
tabMap = {};

// Images from sprites.png: [x, y, w, h]
spriteBig = {
  "4": [1,  1, 12, 16],
  "6": [14, 1, 12, 16],
  "?": [27, 1, 12, 16],
};
spriteSmall = {
  "4": [40, 1, 6, 6],
  "6": [40, 8, 6, 6],
};

// Destination coordinates: [x, y]
targetBig = [1, 2];
targetSmall1 = [13, 2];
targetSmall2 = [13, 9];

// pattern is 0..3 characters, each '4', '6', or '?'.
function buildIcon(pattern) {
  var canvas = document.getElementById("canvas");
  var ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (pattern.length >= 1) {
    drawSprite(ctx, targetBig, spriteBig[pattern.charAt(0)]);
  }
  if (pattern.length >= 2) {
    drawSprite(ctx, targetSmall1, spriteSmall[pattern.charAt(1)]);
  }
  if (pattern.length >= 3) {
    drawSprite(ctx, targetSmall2, spriteSmall[pattern.charAt(2)]);
  }
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function drawSprite(ctx, target, source) {
  // (image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
  ctx.drawImage(document.getElementById("sprites"),
                source[0], source[1], source[2], source[3],
                target[0], target[1], source[2], source[3]);
}

function addrToVersion(addr) {
  if (addr && addr.indexOf(":") >= 0) return "6";
  if (addr && addr.indexOf(".") >= 0) return "4";
  return "?";
}

function renderTabInfo(tabInfo) {
  var tabId = tabInfo.tabId;
  var domains = Object.keys(tabInfo.domains).sort();
  var has4 = false;
  var has6 = false;
  // Build some [domain, addr, version, fromCache] tuples.
  var mainTuple = [tabInfo.mainDomain, "unknown", "?", false];
  var tuples = [mainTuple];
  for (var i = 0; i < domains.length; i++) {
    var domain = domains[i];
    var addr = tabInfo.domains[domain].addr;
    var version = addrToVersion(addr);
    var fromCache = tabInfo.domains[domain].fromCache;
    if (domain == mainTuple[0]) {
      mainTuple[1] = addr;
      mainTuple[2] = version;
      mainTuple[3] = fromCache;
    } else {
      tuples.push([domain, addr, version, fromCache]);
      switch (version) {
        case "4": has4 = true; break;
        case "6": has6 = true; break;
      }
    }
  }

  var pattern = mainTuple[2];
  if (has4) pattern += "4";
  if (has6) pattern += "6";

  var popupUrl = "popup.html#" + JSON.stringify(tuples);

  chrome.pageAction.setIcon({"tabId": tabId, "imageData": buildIcon(pattern)});
  chrome.pageAction.setPopup({"tabId": tabId, "popup": popupUrl});
  chrome.pageAction.show(tabId);
}

function renderTabInfoWithThrottle(tabInfo) {
  if (tabInfo.throttled >= 0) {
    // To conserve CPU, don't redraw anything until the timer expires.
    tabInfo.throttled++;
    return;
  }

  renderTabInfo(tabInfo);

  tabInfo.throttled = 0;
  setTimeout(
    function() {
      if (!tabInfo.deleted && tabInfo.throttled > 0) {
        renderTabInfo(tabInfo);
      }
      tabInfo.throttled = -1;
    },
    500
  );
}

function deleteTabInfo(tabId) {
  var tabInfo = tabMap[tabId];
  delete tabMap[tabId];
  if (tabInfo) {
    // Tell any in-flight requests/timeouts to ignore this instance.
    tabInfo.deleted = true;
  }
}

function urlToHost(url) {
  var a = document.createElement("a");
  a.href = url;
  return a.hostname;
}

// -- webNavigation --

chrome.experimental.webNavigation.onCommitted.addListener(
  function(details) {
    if (details.frameId != 0) {
      return;
    }
    var tabInfo = tabMap[details.tabId];
    if (!tabInfo) {
      return;
    }
    tabInfo.committed = true;
    tabInfo.mainDomain = urlToHost(details.url);
    renderTabInfoWithThrottle(tabInfo);
  }
);

// -- webRequest --

chrome.experimental.webRequest.onBeforeRequest.addListener(
  function (details) {
    if (details.type == "main_frame") {
      deleteTabInfo(details.tabId);
      tabMap[details.tabId] = {
        tabId: details.tabId,
        committed: false,  // has wN.onCommitted() fired yet?
        mainDomain: "",    // Set by wN.onCommitted()
        domains: {},       // Updated whenever we get some IPs.
        throttled: -1,     // >= 0 if the throttle timeout is active.
        deleted: false,    // True if this object is no longer in tabMap.
      };
    }
    var tabInfo = tabMap[details.tabId];
    if (!tabInfo) {
      return;
    }
    requestMap[details.requestId] = {
      tabInfo: tabInfo,
    };
  }
);

chrome.experimental.webRequest.onResponseStarted.addListener(
  function (details) {
    var requestInfo = requestMap[details.requestId];
    delete requestMap[details.requestId];
    if (!requestInfo) {
      return;
    }
    if (!details.ip) {
      return;
    }
    var tabInfo = requestInfo.tabInfo;
    if (tabInfo.deleted) {
      return;
    }

    var domain = urlToHost(details.url);
    var oldDomainInfo = tabInfo.domains[domain];

    // Limit the number of domains per page, to avoid wasting RAM.
    if (!oldDomainInfo && Object.keys(tabInfo.domains).length >= 100) {
      return;
    }

    // Don't allow a cached IP to overwrite an actually-connected IP.
    if (details.fromCache && oldDomainInfo && !oldDomainInfo.fromCache) {
      return;
    }

    tabInfo.domains[domain] = {
      addr: details.ip,
      fromCache: details.fromCache
    };
    if (tabInfo.committed) {
      renderTabInfoWithThrottle(tabInfo);
    }
  }
);

chrome.experimental.webRequest.onCompleted.addListener(
  function(details) {
    delete requestMap[details.requestId];
  }
);

chrome.experimental.webRequest.onErrorOccurred.addListener(
  function(details) {
    delete requestMap[details.requestId];
  }
);

// -- tabs --

chrome.tabs.onRemoved.addListener(
  function(tabId, removeInfo) {
    deleteTabInfo(tabId);
  }
);

</script>
</head>

<body>
<img id="sprites" src="sprites.png">
<canvas id="canvas" width="19" height="19"></canvas>
</body>
</html>
