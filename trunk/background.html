<!--
Copyright (C) 2011  Paul Marks  http://www.pmarks.net/

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
<script type="text/javascript">

/*
Lifecycle documentation:

The purpose of requestMap is to copy tabInfo from wR.onBeforeRequest to
wR.onResponseStarted (where the IP address is available.)  A map entry
normally begins/ends with these two calls, but it could also be deleted
in wR.onCompleted or wR.onErrorOccurred if something bad happens.

An entry in tabMap tries to approximate one "page view".  It begins (or resets)
in wR.onBeforeRequest(main_frame), and goes away when the tab ceases to exist.
(see deleteTabInfoLater for details.)

UI updates begin in wN.onCommitted, which (hopefully) comes after
wR.onResponseStarted(main_frame).  Updates continue as new requests are made,
and stop in wR.onBeforeRequest(main_frame), i.e. the next page load.

Note: I considered starting the UI updates in wR.onCompleted(main_frame), but
that sometimes fires too early, and the icon gets erased.  Thus, wN.onCommitted
is the best "start drawing" event I could find.
*/

// requestId -> {tabInfo}
requestMap = {};

// For the list of fields, see onBeforeRequest() below.
tabMap = {};

// Images from sprites.png: [x, y, w, h]
spriteBig = {
  "4": [1,  1, 12, 16],
  "6": [14, 1, 12, 16],
  "?": [27, 1, 12, 16],
};
spriteSmall = {
  "4": [40, 1, 6, 6],
  "6": [40, 8, 6, 6],
};

// Destination coordinates: [x, y]
targetBig = [1, 2];
targetSmall1 = [13, 2];
targetSmall2 = [13, 9];

// pattern is 0..3 characters, each '4', '6', or '?'.
function buildIcon(pattern) {
  var canvas = document.getElementById("canvas");
  var ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (pattern.length >= 1) {
    drawSprite(ctx, targetBig, spriteBig[pattern.charAt(0)]);
  }
  if (pattern.length >= 2) {
    drawSprite(ctx, targetSmall1, spriteSmall[pattern.charAt(1)]);
  }
  if (pattern.length >= 3) {
    drawSprite(ctx, targetSmall2, spriteSmall[pattern.charAt(2)]);
  }
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function drawSprite(ctx, target, source) {
  // (image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
  ctx.drawImage(document.getElementById("sprites"),
                source[0], source[1], source[2], source[3],
                target[0], target[1], source[2], source[3]);
}

function addrToVersion(addr) {
  if (addr && addr.indexOf(":") >= 0) return "6";
  if (addr && addr.indexOf(".") >= 0) return "4";
  return "?";
}

function renderTabInfo(tabInfo) {
  var tabId = tabInfo.tabId;
  var domains = Object.keys(tabInfo.domains).sort();
  var has4 = false;
  var has6 = false;
  // Build some [domain, addr, version, fromCache] tuples.
  var mainTuple = [tabInfo.mainDomain, "unknown", "?", false];
  var tuples = [mainTuple];
  for (var i = 0; i < domains.length; i++) {
    var domain = domains[i];
    var addr = tabInfo.domains[domain].addr;
    var version = addrToVersion(addr);
    var fromCache = tabInfo.domains[domain].fromCache;
    if (domain == mainTuple[0]) {
      mainTuple[1] = addr;
      mainTuple[2] = version;
      mainTuple[3] = fromCache;
    } else {
      tuples.push([domain, addr, version, fromCache]);
      switch (version) {
        case "4": has4 = true; break;
        case "6": has6 = true; break;
      }
    }
  }

  var pattern = mainTuple[2];
  if (has4) pattern += "4";
  if (has6) pattern += "6";

  var popupUrl = "popup.html#" + JSON.stringify(tuples);

  chrome.pageAction.setIcon({"tabId": tabId, "imageData": buildIcon(pattern)});
  chrome.pageAction.setPopup({"tabId": tabId, "popup": popupUrl});
  chrome.pageAction.show(tabId);
}

function renderTabInfoWithThrottle(tabInfo) {
  if (tabInfo.throttled >= 0) {
    // To conserve CPU, don't redraw anything until the timer expires.
    tabInfo.throttled++;
    return;
  }

  renderTabInfo(tabInfo);

  tabInfo.throttled = 0;
  setTimeout(
    function() {
      if (!tabInfo.deleted && tabInfo.throttled > 0) {
        renderTabInfo(tabInfo);
      }
      tabInfo.throttled = -1;
    },
    500
  );
}

function deleteTabInfo(tabId) {
  var tabInfo = tabMap[tabId];
  delete tabMap[tabId];
  if (!tabInfo) {
    return;
  }
  // Tell any in-flight requests/timeouts to ignore this instance.
  tabInfo.deleted = true;

  // Unsubscribe from the tab deletion event.
  if (tabInfo.port) {
    tabInfo.port.disconnect();
  }
}

// Create a connection to this tabId, and delete it from tabMap when the
// tab ceases to exist.
//
// If the tabId belongs to a hidden tab used for pre-rendering, then we'll
// receive the callback almost immedately, and an ugly error will appear in
// the console:
//   "Port error: Could not establish connection. Receiving end does not exist."
// In some cases, the pre-rendered page won't have any IP information, but
// that's better than leaking memory, and/or a deluge of pageAction errors.
// See http://crbug.com/93646.
//
// And to top it all off, we only call this from wN.onCommitted, because my
// experiments indicate that any Port created before then can disconnect
// spuriously as the page is loading.
function deleteTabInfoLater(tabInfo) {
  if (tabInfo.port) {
    // This shouldn't really happen.
    return;
  }
  tabInfo.port = chrome.tabs.connect(tabInfo.tabId);
  tabInfo.port.onDisconnect.addListener(function() {
    if (!tabInfo.deleted) {
      deleteTabInfo(tabInfo.tabId);
    }
  });
}

function urlToHost(url) {
  var a = document.createElement("a");
  a.href = url;
  if (a.protocol == 'file:') {
    return "file://";
  }
  return a.hostname;
}

// -- webNavigation --

chrome.experimental.webNavigation.onCommitted.addListener(
  function(details) {
    if (details.frameId != 0) {
      return;
    }
    var tabInfo = tabMap[details.tabId];
    if (!tabInfo) {
      return;
    }
    tabInfo.committed = true;
    tabInfo.mainDomain = urlToHost(details.url);
    renderTabInfoWithThrottle(tabInfo);
    deleteTabInfoLater(tabInfo);
  }
);

// -- webRequest --

chrome.experimental.webRequest.onBeforeRequest.addListener(
  function (details) {
    if (!details.tabId || details.tabId == -1) {
      // This request isn't related to a tab.
      return;
    }
    var isMainFrame = (details.type == "main_frame");
    if (isMainFrame) {
      deleteTabInfo(details.tabId);
      tabMap[details.tabId] = {
        tabId: details.tabId,
        committed: false,  // has wN.onCommitted() fired yet?
        mainDomain: "",    // Set by wN.onCommitted()
        domains: {},       // Updated whenever we get some IPs.
        throttled: -1,     // >= 0 if the throttle timeout is active.
        deleted: false,    // True if this object is no longer in tabMap.
        port: null,        // Watches for the tab to go away.
      };
    }
    var tabInfo = tabMap[details.tabId];
    if (!tabInfo) {
      return;
    }
    requestMap[details.requestId] = {
      tabInfo: tabInfo,
      isMainFrame: isMainFrame,
    };
  }
);

chrome.experimental.webRequest.onResponseStarted.addListener(
  function (details) {
    var requestInfo = requestMap[details.requestId];
    if (!requestInfo) {
      return;
    }
    var tabInfo = requestInfo.tabInfo;
    if (tabInfo.deleted) {
      return;
    }

    var domain = urlToHost(details.url);
    if (!domain) {
      return;
    }
    var oldDomainInfo = tabInfo.domains[domain];

    // Limit the number of domains per page, to avoid wasting RAM.
    if (!oldDomainInfo && Object.keys(tabInfo.domains).length >= 100) {
      return;
    }

    // Don't allow a cached IP to overwrite an actually-connected IP.
    if (details.fromCache && oldDomainInfo && !oldDomainInfo.fromCache) {
      return;
    }

    tabInfo.domains[domain] = {
      addr: details.ip || "(no address)",
      fromCache: details.fromCache
    };
    if (tabInfo.committed) {
      renderTabInfoWithThrottle(tabInfo);
    }
  }
);

chrome.experimental.webRequest.onCompleted.addListener(
  function(details) {
    delete requestMap[details.requestId];
  }
);

chrome.experimental.webRequest.onErrorOccurred.addListener(
  function(details) {
    var requestInfo = requestMap[details.requestId];
    delete requestMap[details.requestId];

    // If the main_frame request failed, then we probably won't receive
    // a wN.onCommitted and start the garbage collector Port, so just
    // delete this immediately.
    if (requestInfo && requestInfo.isMainFrame) {
      deleteTabInfo(requestInfo.tabInfo.tabId);
    }
  }
);

</script>
</head>

<body>
<img id="sprites" src="sprites.png">
<canvas id="canvas" width="19" height="19"></canvas>
</body>
</html>
