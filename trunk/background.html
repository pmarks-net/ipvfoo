<html>
<head>
<script type="text/javascript" src="lru.js"></script>
<script type="text/javascript">

// requestId -> { tabId, isMainFrame }
requestMap = {};

// Cache of recent domain -> ip mappings from main_frame requests.
// This is a hack to work around http://crbug.com/88625
domainAddrCache = new LRU(32);

// tab -> { mainDomain, addrs: {domain -> ip} }
tabMap = {};

// Images from sprites.png: [x, y, w, h]
spriteBig = {
  "4": [1,  1, 12, 16],
  "6": [14, 1, 12, 16],
  "?": [27, 1, 12, 16],
};
spriteSmall = {
  "4": [40, 1, 6, 6],
  "6": [40, 8, 6, 6],
};

// Destination coordinates: [x, y]
targetBig = [1, 2];
targetSmall1 = [13, 2];
targetSmall2 = [13, 9];

// pattern is 0..3 characters, each '4', '6', or '?'.
function buildIcon(pattern) {
  var canvas = document.getElementById("canvas");
  var ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (pattern.length >= 1) {
    drawSprite(ctx, targetBig, spriteBig[pattern.charAt(0)]);
  }
  if (pattern.length >= 2) {
    drawSprite(ctx, targetSmall1, spriteSmall[pattern.charAt(1)]);
  }
  if (pattern.length >= 3) {
    drawSprite(ctx, targetSmall2, spriteSmall[pattern.charAt(2)]);
  }
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function drawSprite(ctx, target, source) {
  // (image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
  ctx.drawImage(document.getElementById("sprites"),
                source[0], source[1], source[2], source[3],
                target[0], target[1], source[2], source[3]);
}

function addrToVersion(addr) {
  if (addr && addr.indexOf(":") >= 0) return "6";
  if (addr && addr.indexOf(".") >= 0) return "4";
  return "?";
}

function renderTabInfo(tabId, tabInfo) {
  var domains = Object.keys(tabInfo.addrs).sort();
  var has4 = false;
  var has6 = false;
  // Build some [domain, addr, version] tuples.
  var mainTuple = [tabInfo.mainDomain, "unknown", "?"];
  var tuples = [mainTuple];
  for (var i = 0; i < domains.length; i++) {
    var domain = domains[i];
    var addr = tabInfo.addrs[domain];
    var version = addrToVersion(addr);
    if (domain == mainTuple[0]) {
      mainTuple[1] = addr;
      mainTuple[2] = version;
    } else {
      tuples.push([domain, addr, version]);
      switch (version) {
        case "4": has4 = true; break;
        case "6": has6 = true; break;
      }
    }
  }

  var pattern = mainTuple[2];
  if (has4) pattern += "4";
  if (has6) pattern += "6";

  var popupUrl = "popup.html#" + JSON.stringify(tuples);

  chrome.pageAction.setIcon({"tabId": tabId, "imageData": buildIcon(pattern)});
  chrome.pageAction.setPopup({"tabId": tabId, "popup": popupUrl});
  chrome.pageAction.show(tabId);
}

function urlToHost(url) {
  var a = document.createElement("a");
  a.href = url;
  return a.hostname;
}

// -- webNavigation --

chrome.experimental.webNavigation.onBeforeNavigate.addListener(
  function(details) {
    if (details.frameId != 0) {
      return;
    }
    
    // This should get updated by onResponseStarted before onCommitted reads it.
    tabMap[details.tabId] = {
      // Domain of the top-level request.
      mainDomain: "",
      // host->IP mapping for all the requests.
      addrs: {}
    };
  }
);

chrome.experimental.webNavigation.onCommitted.addListener(
  function(details) {
    if (details.frameId != 0) {
      return;
    }
    var tabInfo = tabMap[details.tabId];
    if (tabInfo == undefined) {
      return;
    }

    var domain = urlToHost(details.url);
    if (tabInfo.addrs[domain] == undefined) {
      var ip = domainAddrCache.getItem(domain);
      if (ip != undefined) {
        tabInfo.addrs[domain] = ip;
      }
    }

    tabInfo.mainDomain = domain;
    renderTabInfo(details.tabId, tabInfo);
  }
);

chrome.experimental.webNavigation.onCompleted.addListener(
  function(details) {
    if (details.frameId != 0) {
      return;
    }
    var tabInfo = tabMap[details.tabId];
    if (tabInfo == undefined) {
      return;
    }
    renderTabInfo(details.tabId, tabInfo);
    delete tabMap[details.tabId];
  }
);

chrome.experimental.webNavigation.onErrorOccurred.addListener(
  function(details) {
    if (details.frameId != 0) {
      return;
    }
    delete tabMap[details.tabId];
  }
);

// -- webRequest --

chrome.experimental.webRequest.onBeforeRequest.addListener(
  function (details) {
    requestMap[details.requestId] = {
      tabId: details.tabId,
      isMainFrame: details.type == "main_frame"
    };
  }
);

chrome.experimental.webRequest.onResponseStarted.addListener(
  function (details) {
    var requestInfo = requestMap[details.requestId];
    if (requestInfo == undefined) {
      return;
    }

    var domain = urlToHost(details.url);
    if (requestInfo.isMainFrame) {
      domainAddrCache.setItem(domain, details.ip);
    }

    var tabInfo = tabMap[requestInfo.tabId];
    if (tabInfo == undefined) {
      return;
    }
    tabInfo.addrs[domain] = details.ip;

    // TODO: when "fromCache" makes it to the dev channel, give uncached IPs
    //       a higher priority in the addrs map.
  }
);

chrome.experimental.webRequest.onCompleted.addListener(
  function(details) {
    delete requestMap[details.requestId];
  }
);

chrome.experimental.webRequest.onErrorOccurred.addListener(
  function(details) {
    delete requestMap[details.requestId];
  }
);

</script>
</head>

<body>
<img id="sprites" src="sprites.png">
<canvas id="canvas" width="19" height="19"></canvas>
</body>
</html>
