<!--
Copyright (C) 2011  Paul Marks  http://www.pmarks.net/

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
<script type="text/javascript">

/*
Lifecycle documentation:

The purpose of requestMap is to copy tabInfo from wR.onBeforeRequest to
wR.onResponseStarted (where the IP address is available.)  A map entry
normally begins/ends with these two calls, but it could also be deleted
in wR.onCompleted or wR.onErrorOccurred if something bad happens.

An entry in tabMap tries to approximate one "page view".  It begins in
wR.onBeforeRequest(main_frame), and goes away either when another page
begins, or when the tab ceases to exist (see awaitTabDeath for details.)

UI updates begin in wN.onCommitted, which (hopefully) comes after
wR.onResponseStarted(main_frame).  Updates continue as new requests are made,
and stop in wR.onBeforeRequest(main_frame), i.e. the next page load.

Notes:
- I considered starting the UI updates in wR.onCompleted(main_frame), but
  that sometimes fires too early, and the icon gets erased.  Thus,
  wN.onCommitted is the best "start drawing" event I could find.
- wN.onCommitted *sometimes* fires without a preceding main_page request.
  I think http://crbug.com/94342 is to blame.
*/

// requestId -> {tabInfo, isMainFrame}
requestMap = {};

// tabId -> TabInfo
tabMap = {};

// Images from sprites.png: [x, y, w, h]
spriteBig = {
  "4": [1,  1, 12, 16],
  "6": [14, 1, 12, 16],
  "?": [27, 1, 12, 16],
};
spriteSmall = {
  "4": [40, 1, 6, 6],
  "6": [40, 8, 6, 6],
};

// Destination coordinates: [x, y]
targetBig = [1, 2];
targetSmall1 = [13, 2];
targetSmall2 = [13, 9];

// pattern is 0..3 characters, each '4', '6', or '?'.
function buildIcon(pattern) {
  var canvas = document.getElementById("canvas");
  var ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (pattern.length >= 1) {
    drawSprite(ctx, targetBig, spriteBig[pattern.charAt(0)]);
  }
  if (pattern.length >= 2) {
    drawSprite(ctx, targetSmall1, spriteSmall[pattern.charAt(1)]);
  }
  if (pattern.length >= 3) {
    drawSprite(ctx, targetSmall2, spriteSmall[pattern.charAt(2)]);
  }
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function drawSprite(ctx, target, source) {
  // (image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
  ctx.drawImage(document.getElementById("sprites"),
                source[0], source[1], source[2], source[3],
                target[0], target[1], source[2], source[3]);
}

function addrToVersion(addr) {
  if (addr && addr.indexOf(":") >= 0) return "6";
  if (addr && addr.indexOf(".") >= 0) return "4";
  return "?";
}

function urlToHost(url) {
  var a = document.createElement("a");
  a.href = url;
  if (a.protocol == 'file:') {
    return "file://";
  }
  return a.hostname;
}

// -- TabInfo --

function pokeTabInfo(tabId, mustBeNew) {
  var oldTabInfo = tabMap[tabId];
  if (oldTabInfo) {
    if (!mustBeNew) {
      return oldTabInfo;
    }
    oldTabInfo.deleteMe();
  }
  return new TabInfo(tabId);
}

TabInfo = function(tabId) {
  this.tabId = tabId;
  this.committed = false;  // has wN.onCommitted() fired yet?
  this.mainDomain = "";    // Set by wN.onCommitted()
  this.domains = {};       // Updated whenever we get some IPs.
  this.lastPattern = "";   // To avoid redundant icon redraws.
  this.deleted = false;    // True if this object is no longer in tabMap.
  this.port = null;        // Watches for the tab to go away.

  if (tabMap[tabId]) throw "Duplicate entry in tabMap";
  tabMap[tabId] = this;
};

TabInfo.prototype.setCommitted = function(mainDomain) {
  this.committed = true;
  this.mainDomain = mainDomain;
  this.updateIcon();
  popups.pushAll(this.tabId);
  this.awaitTabDeath();
};

TabInfo.prototype.addDomain = function(domain, addr, fromCache) {
  var oldDomainInfo = this.domains[domain];

  if (!oldDomainInfo) {
    // Limit the number of domains per page, to avoid wasting RAM.
    if (Object.keys(this.domains).length >= 100) {
      return;
    }
  } else {
    // Don't allow a cached IP to overwrite an actually-connected IP.
    if (fromCache && !oldDomainInfo.fromCache) {
      return;
    }
    // Don't update if nothing has changed.
    if (oldDomainInfo.addr == addr && oldDomainInfo.fromCache == fromCache) {
      return;
    }
  }

  this.domains[domain] = {
    addr: addr,
    fromCache: fromCache,
  };

  if (this.committed) {
    this.updateIcon();
    popups.pushOne(this.tabId, domain, addr, fromCache);
  }
};

TabInfo.prototype.updateIcon = function() {
  var domains = Object.keys(this.domains);
  var pattern = "?";
  var has4 = false;
  var has6 = false;
  for (var i = 0; i < domains.length; i++) {
    var domain = domains[i];
    var addr = this.domains[domain].addr;
    var version = addrToVersion(addr);
    if (domain == this.mainDomain) {
      pattern = version;
    } else {
      switch (version) {
        case "4": has4 = true; break;
        case "6": has6 = true; break;
      }
    }
  }
  if (has4) pattern += "4";
  if (has6) pattern += "6";

  // Don't waste time redrawing the same icon.
  if (this.lastPattern == pattern) {
    return;
  }
  this.lastPattern = pattern;

  chrome.pageAction.setIcon({
    "tabId": this.tabId,
    "imageData": buildIcon(pattern),
  });
  chrome.pageAction.setPopup({
    "tabId": this.tabId,
    "popup": "popup.html#" + this.tabId,
  });
  chrome.pageAction.show(this.tabId);
};

// Build some [domain, addr, version, fromCache] tuples, for a popup.
TabInfo.prototype.getTuples = function() {
  var domains = Object.keys(this.domains).sort();
  var mainTuple = [this.mainDomain, "unknown", "?", false];
  var tuples = [mainTuple];
  for (var i = 0; i < domains.length; i++) {
    var domain = domains[i];
    var addr = this.domains[domain].addr;
    var version = addrToVersion(addr);
    var fromCache = this.domains[domain].fromCache;
    if (domain == mainTuple[0]) {
      mainTuple[1] = addr;
      mainTuple[2] = version;
      mainTuple[3] = fromCache;
    } else {
      tuples.push([domain, addr, version, fromCache]);
    }
  }
  return tuples;
}

// Create a connection to this tabId, and delete it from tabMap when the
// tab ceases to exist.
//
// If the tabId belongs to a hidden tab used for pre-rendering, then we'll
// receive the callback almost immedately, and an ugly error will appear in
// the console:
//   "Port error: Could not establish connection. Receiving end does not exist."
// In some cases, the pre-rendered page won't have any IP information, but
// that's better than leaking memory, and/or a deluge of pageAction errors.
// See http://crbug.com/93646.
//
// And to top it all off, we only call this from wN.onCommitted, because my
// experiments indicate that any Port created before then can disconnect
// spuriously as the page is loading.
TabInfo.prototype.awaitTabDeath = function() {
  if (this.port) {
    // This is pretty unusual, but it is sometimes possible for a tab to
    // hit onCommitted twice without a main_frame request in between.
    this.port.disconnect();
  }
  this.port = chrome.tabs.connect(this.tabId);

  var that = this;
  this.port.onDisconnect.addListener(function() {
    that.deleteMe();
  });
};

TabInfo.prototype.deleteMe = function() {
  if (this.deleted) {
    return;
  }

  // Tell any in-flight requests/timeouts to ignore this instance.
  this.deleted = true;

  // Unsubscribe from the tab deletion event.
  if (this.port) {
    this.port.disconnect();
  }

  delete tabMap[this.tabId];
};

// -- Popups --

// This class keeps track of the visible popup windows,
// and streams changes to them as they occur.
Popups = function() {
  this.map = {};            // tabId -> popup window
  this.hasTimeout = false;  // Is the GC scheduled?
}

// Attach a new popup window, and start sending it updates.
Popups.prototype.attachWindow = function(win) {
  this.map[win.tabId] = win;
  this.pushAll(win.tabId);
  this.garbageCollect();
}

// Periodically make sure this.map is a subset of the visible popups.
Popups.prototype.garbageCollect = function() {
  if (this.hasTimeout) {
    return;
  }
  if (Object.keys(this.map).length == 0) {
    return;
  }
  this.hasTimeout = true;
  var that = this;
  setTimeout(function() {
    // Find all the tabs with active popups.
    var popupTabs = {};
    var popups = chrome.extension.getViews({type:"popup"});
    for (var i = 0; i < popups.length; i++) {
      popupTabs[popups[i].tabId] = true;
    }

    // Drop references to the inactive popups.
    var storedTabs = Object.keys(that.map);
    for (var i = 0; i < storedTabs.length; i++) {
      var tabId = storedTabs[i];
      if (!popupTabs[tabId]) {
        delete that.map[tabId];
      }
    }

    // Maybe schedule another run.
    that.hasTimeout = false;
    that.garbageCollect();
  }, 5000);
};

Popups.prototype.pushAll = function(tabId) {
  var win = this.map[tabId];
  var tabInfo = tabMap[tabId];
  if (win && tabInfo) {
    win.pushAll(tabInfo.getTuples());
  }
}

Popups.prototype.pushOne = function(tabId, domain, addr, fromCache) {
  var win = this.map[tabId];
  if (win) {
    win.pushOne([domain, addr, addrToVersion(addr), fromCache]);
  }
}

popups = new Popups();

// -- webNavigation --

chrome.webNavigation.onCommitted.addListener(
  function(details) {
    if (details.frameId != 0) {
      return;
    }
    var mainDomain = urlToHost(details.url);
    pokeTabInfo(details.tabId, false).setCommitted(mainDomain);
  }
);

// -- webRequest --

chrome.webRequest.onBeforeRequest.addListener(
  function (details) {
    if (!details.tabId || details.tabId == -1) {
      // This request isn't related to a tab.
      return;
    }
    var isMainFrame = (details.type == "main_frame");
    if (isMainFrame) {
      pokeTabInfo(details.tabId, true);
    }
    var tabInfo = tabMap[details.tabId];
    if (!tabInfo) {
      return;
    }
    requestMap[details.requestId] = {
      tabInfo: tabInfo,
      isMainFrame: isMainFrame,
    };
  }
);

chrome.webRequest.onResponseStarted.addListener(
  function (details) {
    var requestInfo = requestMap[details.requestId];
    if (!requestInfo || requestInfo.tabInfo.deleted) {
      return;
    }
    var domain = urlToHost(details.url);
    if (!domain) {
      return;
    }
    var addr = details.ip || "(no address)";
    requestInfo.tabInfo.addDomain(domain, addr, details.fromCache);
  }
);

chrome.webRequest.onCompleted.addListener(
  function(details) {
    delete requestMap[details.requestId];
  }
);

chrome.webRequest.onErrorOccurred.addListener(
  function(details) {
    var requestInfo = requestMap[details.requestId];
    delete requestMap[details.requestId];

    // If the main_frame request failed, then we probably won't receive
    // a wN.onCommitted and start the garbage collector Port, so just
    // delete this immediately.
    if (requestInfo && requestInfo.isMainFrame) {
      requestInfo.tabInfo.deleteMe();
    }
  }
);

</script>
</head>

<body>
<img id="sprites" src="sprites.png">
<canvas id="canvas" width="19" height="19"></canvas>
</body>
</html>
